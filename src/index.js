// Step 1. Import the 'mysql' and 'dotenv' packages.
import {createConnection} from "mysql";
import dotenv from "dotenv";
import * as fs from "fs";
import * as util from "util";

/**
 * Database connection.
 * @typedef Connection
 */

/**
 * Player.
 * @typedef {Object} Player
 * @property {number} id Player ID.
 * @property {number} coins Coins.
 * @property {number} goods Goods.
 */

// Step 2. Load environment variables from .env file via the 'dotenv' package.
dotenv.config();

/**
 * üîå Step 3 (Option 1). Establish a connection to TiDB cluster with connection URL.
 *
 * @returns {Promise<Connection>}
 */
async function connectWithURL() {
    try {
        const url = process.env.DATABASE_URL || 'mysql://root@localhost:4000/test';
        return createConnection(url);
    } catch (err) {
        throw new Error(`Failed to connect to TiDB cluster: ${err.message}`);
    }
}

/**
 * üîå Step 3 (Option 2). Establish a connection to TiDB cluster with connection options.
 *
 * @returns {Promise<Connection>}
 */
async function connectWithOptions() {
    try {
        const options = {
            host: process.env.TIDB_HOST || '127.0.0.1',
            port: process.env.TIDB_PORT || 4000,
            user: process.env.TIDB_USER || 'root',
            password: process.env.TIDB_PASSWORD || '',
            database: process.env.TIDB_DATABASE || 'test',
            ssl: process.env.TIDB_ENABLE_SSL === 'true' ? {
                minVersion: 'TLSv1.2',
                ca: process.env.TIDB_CA_PATH ? fs.readFileSync(process.env.TIDB_CA_PATH) : undefined
            } : null,
        }
        return createConnection(options);
    } catch (err) {
        throw new Error(`Failed to connect to TiDB cluster: ${err.message}`);
    }
}

/**
 * üö™Main function.
 * @returns {Promise<void>}
 */
async function main() {
    let conn = process.env.DATABASE_URL ? await connectWithURL() : await connectWithOptions();
    try {
        const version = await getTiDBVersion(conn);
        console.log(`üîå Connected to TiDB cluster! (TiDB version: ${version})`);

        console.log('‚è≥  Loading sample game data...');
        await loadSampleGameData(conn);
        console.log('‚úÖ  Loaded sample game data.\n');

        const newPlayer = await createPlayer(conn, 100, 100);
        console.log(`üÜï Created a new player with ID ${newPlayer}.`);

        const player = await getPlayerByID(conn, newPlayer);
        console.log(`‚ÑπÔ∏è Got Player ${player.id}: Player { id: ${player.id}, coins: ${player.coins}, goods: ${player.goods} }`);

        const updatedRows = await updatePlayer(conn, player.id, 50, 50);
        console.log(`üî¢ Added 50 coins and 50 goods to player ${player.id}, updated ${updatedRows} row.`);

        const deletedRows = await deletePlayerByID(conn, player.id);
        console.log(`üöÆ Deleted ${deletedRows} player data.`);
    } finally {
        // Step 4. Close the connection.
        await conn.end();
    }
}

void main();

/**
 * Get TiDB version.
 *
 * @param conn {Connection}
 * @returns {Promise<string>}
 */
async function getTiDBVersion(conn) {
    return new Promise((resolve, reject) => {
        conn.query('SELECT VERSION() AS tidb_version;', (err, rows) => {
            if (err) {
                reject(err);
            } else {
                resolve(rows[0]['tidb_version']);
            }
        });
    });
}

/**
 * Load sample game data.
 *
 * @param conn {Connection}
 * @returns {Promise<void>}
 */
async function loadSampleGameData(conn) {
    const content = fs.readFileSync('sql/game.init.sql', 'utf8');
    const sqls = content.split(';');
    const query = util.promisify(conn.query).bind(conn);

    for (const sql of sqls) {
        if (sql.trim() === '') {
            continue;
        }
        await query(sql);
    }
}

/**
 * üÜï CREATE a new player.
 *
 * @param conn {Connection} Database connection.
 * @param coins {number} Initial coins.
 * @param goods {number} Initial goods.
 * @returns {Promise<number>} The ID auto-generated by TiDB for the new player.
 */
async function createPlayer(conn, coins, goods) {
    return new Promise((resolve, reject) => {
        conn.query('INSERT INTO players (coins, goods) VALUES (?, ?);', [coins, goods], (err, ok) => {
            if (err) {
                reject(err);
            } else {
                resolve(ok.insertId);
            }
        })
    });
}

/**
 * ‚ÑπÔ∏è READ player information by ID.
 *
 * @param conn {Connection} Database connection.
 * @param id {number} The ID of the player to get.
 * @returns {Promise<Player>}
 */
async function getPlayerByID(conn, id) {
    return new Promise((resolve, reject) => {
        conn.query( 'SELECT id, coins, goods FROM players WHERE id = ?;', [id], (err, rows) => {
            if (err) {
                reject(err);
            } else {
                resolve(rows[0]);
            }
        });
    });
}

/**
 * üî¢ UPDATE player.
 *
 * @param conn {Connection} Database connection.
 * @param playerID {number} The ID of the player to update.
 * @param incCoins {number} The increased coins.
 * @param incGoods {number} The increased goods.
 * @returns {Promise<number>} The number of affected rows, return 1 if updated successfully.
 */
async function updatePlayer(conn, playerID, incCoins, incGoods) {
    return new Promise((resolve, reject) => {
        conn.query(
            'UPDATE players SET coins = coins + ?, goods = goods + ? WHERE id = ?;',
            [incCoins, incGoods, playerID],
            (err, ok) => {
                if (err) {
                    reject(err);
                } else {
                    resolve(ok.affectedRows);
                }
            }
        );
    });
}

/**
 * üöÆ DELETE player by ID.
 *
 * @param conn {Connection} Database connection.
 * @param id {number} The ID of the player to delete.
 * @returns {Promise<number>} The number of affected rows, return 1 if deleted successfully.
 */
async function deletePlayerByID(conn, id) {
    return new Promise((resolve, reject) => {
        conn.query('DELETE FROM players WHERE id = ?;', [id], (err, ok) => {
            if (err) {
                reject(err);
            } else {
                resolve(ok.affectedRows);
            }
        });
    });
}
